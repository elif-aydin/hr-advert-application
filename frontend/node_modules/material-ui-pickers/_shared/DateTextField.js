'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.DateTextField = undefined;

var _extends2 = require('babel-runtime/helpers/extends');

var _extends3 = _interopRequireDefault(_extends2);

var _objectWithoutProperties2 = require('babel-runtime/helpers/objectWithoutProperties');

var _objectWithoutProperties3 = _interopRequireDefault(_objectWithoutProperties2);

var _getPrototypeOf = require('babel-runtime/core-js/object/get-prototype-of');

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require('babel-runtime/helpers/createClass');

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _propTypes = require('prop-types');

var _propTypes2 = _interopRequireDefault(_propTypes);

var _Icon = require('@material-ui/core/Icon');

var _Icon2 = _interopRequireDefault(_Icon);

var _InputAdornment = require('@material-ui/core/InputAdornment');

var _InputAdornment2 = _interopRequireDefault(_InputAdornment);

var _TextField = require('@material-ui/core/TextField');

var _TextField2 = _interopRequireDefault(_TextField);

var _IconButton = require('@material-ui/core/IconButton');

var _IconButton2 = _interopRequireDefault(_IconButton);

var _withStyles = require('@material-ui/core/styles/withStyles');

var _withStyles2 = _interopRequireDefault(_withStyles);

var _propTypes3 = require('../constants/prop-types');

var _propTypes4 = _interopRequireDefault(_propTypes3);

var _MaskedInput = require('./MaskedInput');

var _MaskedInput2 = _interopRequireDefault(_MaskedInput);

var _WithUtils = require('../_shared/WithUtils');

var _WithUtils2 = _interopRequireDefault(_WithUtils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var getDisplayDate = function getDisplayDate(props) {
  var utils = props.utils,
      value = props.value,
      format = props.format,
      invalidLabel = props.invalidLabel,
      emptyLabel = props.emptyLabel,
      labelFunc = props.labelFunc;


  var isEmpty = value === null;
  var date = utils.date(value);

  if (labelFunc) {
    return labelFunc(isEmpty ? null : date, invalidLabel);
  }

  if (isEmpty) {
    return emptyLabel;
  }

  return utils.isValid(date) ? utils.format(date, format) : invalidLabel;
};

var getError = function getError(value, props) {
  var utils = props.utils,
      maxDate = props.maxDate,
      minDate = props.minDate,
      disablePast = props.disablePast,
      disableFuture = props.disableFuture,
      maxDateMessage = props.maxDateMessage,
      minDateMessage = props.minDateMessage,
      invalidDateMessage = props.invalidDateMessage;


  if (!utils.isValid(value)) {
    // if null - do not show error
    if (utils.isNull(value)) {
      return '';
    }

    return invalidDateMessage;
  }

  if (maxDate && utils.isAfter(value, maxDate) || disableFuture && utils.isAfter(value, utils.endOfDay(utils.date()))) {
    return maxDateMessage;
  }

  if (minDate && utils.isBefore(value, minDate) || disablePast && utils.isBefore(value, utils.startOfDay(utils.date()))) {
    return minDateMessage;
  }

  return '';
};

var DateTextField = exports.DateTextField = function (_PureComponent) {
  (0, _inherits3.default)(DateTextField, _PureComponent);

  function DateTextField() {
    var _ref;

    var _temp, _this, _ret;

    (0, _classCallCheck3.default)(this, DateTextField);

    for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return _ret = (_temp = (_this = (0, _possibleConstructorReturn3.default)(this, (_ref = DateTextField.__proto__ || (0, _getPrototypeOf2.default)(DateTextField)).call.apply(_ref, [this].concat(args))), _this), _this.state = DateTextField.updateState(_this.props), _this.commitUpdates = function (value) {
      var _this$props = _this.props,
          clearable = _this$props.clearable,
          onClear = _this$props.onClear,
          utils = _this$props.utils,
          format = _this$props.format,
          onError = _this$props.onError;


      if (value === '') {
        if (_this.props.value === null) {
          _this.setState(DateTextField.updateState(_this.props));
        } else if (clearable && onClear) {
          onClear();
        }

        return;
      }

      var oldValue = utils.date(_this.state.value);
      var newValue = utils.parse(value, format);
      var error = getError(newValue, _this.props);

      _this.setState({
        error: error,
        displayValue: value,
        value: error ? newValue : oldValue
      }, function () {
        if (!error && !utils.isEqual(newValue, oldValue)) {
          _this.props.onChange(newValue);
        }

        if (error && onError) {
          onError(newValue, error);
        }
      });
    }, _this.handleBlur = function (e) {
      if (_this.props.keyboard) {
        e.preventDefault();
        e.stopPropagation();

        _this.commitUpdates(e.target.value);
        if (_this.props.onBlur) {
          _this.props.onBlur(e);
        }
      }
    }, _this.handleChange = function (e) {
      var _this$props2 = _this.props,
          utils = _this$props2.utils,
          format = _this$props2.format;

      var parsedValue = utils.parse(e.target.value, format);

      _this.setState({
        displayValue: e.target.value,
        error: getError(parsedValue, _this.props)
      });
    }, _this.handleFocus = function (e) {
      e.stopPropagation();
      e.preventDefault();

      if (!_this.props.keyboard) {
        _this.openPicker(e);
      }
    }, _this.handleKeyPress = function (e) {
      if (e.key === 'Enter') {
        if (!_this.props.disableOpenOnEnter) {
          _this.openPicker(e);
        } else {
          _this.commitUpdates(e.target.value);
        }
      }
    }, _this.openPicker = function (e) {
      var _this$props3 = _this.props,
          disabled = _this$props3.disabled,
          onClick = _this$props3.onClick;


      if (!disabled) {
        onClick(e);
      }
    }, _temp), (0, _possibleConstructorReturn3.default)(_this, _ret);
  }

  (0, _createClass3.default)(DateTextField, [{
    key: 'componentDidUpdate',
    value: function componentDidUpdate(prevProps) {
      if (!this.props.utils.isEqual(this.props.value, prevProps.value) || prevProps.format !== this.props.format || prevProps.maxDate !== this.props.maxDate || prevProps.minDate !== this.props.minDate || prevProps.emptyLabel !== this.props.emptyLabel || prevProps.utils !== this.props.utils) {
        /* eslint-disable-next-line react/no-did-update-set-state */
        this.setState(DateTextField.updateState(this.props));
      }
    }
  }, {
    key: 'render',
    value: function render() {
      var _props = this.props,
          adornmentPosition = _props.adornmentPosition,
          classes = _props.classes,
          clearable = _props.clearable,
          disabled = _props.disabled,
          disableFuture = _props.disableFuture,
          disableOpenOnEnter = _props.disableOpenOnEnter,
          disablePast = _props.disablePast,
          emptyLabel = _props.emptyLabel,
          format = _props.format,
          InputAdornmentProps = _props.InputAdornmentProps,
          InputProps = _props.InputProps,
          invalidDateMessage = _props.invalidDateMessage,
          invalidLabel = _props.invalidLabel,
          keyboard = _props.keyboard,
          keyboardIcon = _props.keyboardIcon,
          labelFunc = _props.labelFunc,
          mask = _props.mask,
          maxDate = _props.maxDate,
          maxDateMessage = _props.maxDateMessage,
          minDate = _props.minDate,
          minDateMessage = _props.minDateMessage,
          onBlur = _props.onBlur,
          onClear = _props.onClear,
          onClick = _props.onClick,
          TextFieldComponent = _props.TextFieldComponent,
          utils = _props.utils,
          value = _props.value,
          other = (0, _objectWithoutProperties3.default)(_props, ['adornmentPosition', 'classes', 'clearable', 'disabled', 'disableFuture', 'disableOpenOnEnter', 'disablePast', 'emptyLabel', 'format', 'InputAdornmentProps', 'InputProps', 'invalidDateMessage', 'invalidLabel', 'keyboard', 'keyboardIcon', 'labelFunc', 'mask', 'maxDate', 'maxDateMessage', 'minDate', 'minDateMessage', 'onBlur', 'onClear', 'onClick', 'TextFieldComponent', 'utils', 'value']);
      var _state = this.state,
          displayValue = _state.displayValue,
          error = _state.error;

      var localInputProps = {
        className: classes.input,
        inputComponent: _MaskedInput2.default,
        inputProps: {
          mask: !keyboard ? null : mask,
          readOnly: !keyboard
        }
      };

      if (keyboard) {
        localInputProps[adornmentPosition + 'Adornment'] = _react2.default.createElement(
          _InputAdornment2.default,
          (0, _extends3.default)({
            position: adornmentPosition
          }, InputAdornmentProps),
          _react2.default.createElement(
            _IconButton2.default,
            {
              disabled: disabled,
              onClick: this.openPicker
            },
            _react2.default.createElement(
              _Icon2.default,
              null,
              ' ',
              keyboardIcon,
              ' '
            )
          )
        );
      }

      return _react2.default.createElement(TextFieldComponent, (0, _extends3.default)({
        onClick: this.handleFocus,
        error: !!error,
        helperText: error,
        onKeyPress: this.handleKeyPress,
        onBlur: this.handleBlur,
        disabled: disabled,
        value: displayValue
      }, other, {
        onChange: this.handleChange,
        InputProps: (0, _extends3.default)({}, localInputProps, InputProps)
      }));
    }
  }]);
  return DateTextField;
}(_react.PureComponent);

DateTextField.updateState = function (props) {
  return {
    value: props.value,
    displayValue: getDisplayDate(props),
    error: getError(props.utils.date(props.value), props)
  };
};

DateTextField.propTypes = {
  classes: _propTypes2.default.shape({}).isRequired,
  value: _propTypes2.default.oneOfType([_propTypes2.default.object, _propTypes2.default.string, _propTypes2.default.number, _propTypes2.default.instanceOf(Date)]),
  minDate: _propTypes4.default.date,
  maxDate: _propTypes4.default.date,
  disablePast: _propTypes2.default.bool,
  disableFuture: _propTypes2.default.bool,
  format: _propTypes2.default.string,
  onBlur: _propTypes2.default.func,
  onChange: _propTypes2.default.func.isRequired,
  onClear: _propTypes2.default.func,
  onClick: _propTypes2.default.func.isRequired,
  clearable: _propTypes2.default.bool,
  utils: _propTypes2.default.object.isRequired,
  disabled: _propTypes2.default.bool,
  InputProps: _propTypes2.default.shape(),
  /** Input mask, used in keyboard mode read more <a href="https://github.com/text-mask/text-mask/blob/master/componentDocumentation.md#readme">here</a> */
  mask: _propTypes2.default.any,
  /** Error message, shown if date is less then minimal date */
  minDateMessage: _propTypes2.default.node,
  /** Error message, shown if date is more then maximal date */
  maxDateMessage: _propTypes2.default.node,
  /** Message displaying in text field, if date is invalid (doesn't work in keyboard mode) */
  invalidLabel: _propTypes2.default.string,
  /** Message displaying in text field, if null passed (doesn't work in keyboard mode) */
  emptyLabel: _propTypes2.default.string,
  /** Dynamic label generation function (date, invalidLabel) => string */
  labelFunc: _propTypes2.default.func,
  /** On/off manual keyboard input mode */
  keyboard: _propTypes2.default.bool,
  /** Icon displayed for open picker button in keyboard mode */
  keyboardIcon: _propTypes2.default.node,
  /** enables/disable automatic opening of the picker when the user clicks enter */
  disableOpenOnEnter: _propTypes2.default.bool,
  /** Message, appearing when date cannot be parsed */
  invalidDateMessage: _propTypes2.default.node,
  /** Component that should replace the default Material-UI TextField */
  TextFieldComponent: _propTypes2.default.oneOfType([_propTypes2.default.string, _propTypes2.default.func]),
  /** Props to pass to keyboard input adornment */
  InputAdornmentProps: _propTypes2.default.object,
  /** Specifies position of keyboard button adornment */
  adornmentPosition: _propTypes2.default.oneOf(['start', 'end']),
  /** Callback firing when date that applied in the keyboard is invalid  */
  onError: _propTypes2.default.func
};
DateTextField.defaultProps = {
  disabled: false,
  invalidLabel: 'Unknown',
  emptyLabel: '',
  value: new Date(),
  labelFunc: undefined,
  format: undefined,
  InputProps: undefined,
  keyboard: false,
  mask: undefined,
  keyboardIcon: 'event',
  disableOpenOnEnter: false,
  invalidDateMessage: 'Invalid Date Format',
  clearable: false,
  onBlur: undefined,
  onClear: undefined,
  disablePast: false,
  disableFuture: false,
  onError: undefined,
  minDate: '1900-01-01',
  maxDate: '2100-01-01',
  minDateMessage: 'Date should not be before minimal date',
  maxDateMessage: 'Date should not be after maximal date',
  TextFieldComponent: _TextField2.default,
  InputAdornmentProps: {},
  adornmentPosition: 'end'
};


var styles = {
  input: {
    alignItems: 'flex-end'
  }
};

exports.default = (0, _withStyles2.default)(styles)((0, _WithUtils2.default)()(DateTextField));